{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///Users/flavioazoup/Desenvolvimento/central_integracoes/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\nimport { Pool } from 'pg'\nimport { PrismaPg } from '@prisma/adapter-pg'\n\nconst prismaClientSingleton = () => {\n    const pool = new Pool({ connectionString: process.env.DATABASE_URL })\n    const adapter = new PrismaPg(pool)\n    return new PrismaClient({ adapter })\n}\n\ntype PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>\n\nconst globalForPrisma = globalThis as unknown as {\n    prisma: PrismaClientSingleton | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? prismaClientSingleton()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;;AAEA,MAAM,wBAAwB;IAC1B,MAAM,OAAO,IAAI,qJAAI,CAAC;QAAE,kBAAkB,QAAQ,GAAG,CAAC,YAAY;IAAC;IACnE,MAAM,UAAU,IAAI,uKAAQ,CAAC;IAC7B,OAAO,IAAI,sMAAY,CAAC;QAAE;IAAQ;AACtC;AAIA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI;AAEhD,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/flavioazoup/Desenvolvimento/central_integracoes/src/server/services/tenant.service.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma'\nimport { auth, currentUser } from '@clerk/nextjs/server'\n\nexport async function getCurrentTenant() {\n    const { userId, orgId } = await auth();\n    if (!userId) return null;\n    const clerkId = orgId || userId;\n\n    let tenant = await prisma.tenant.findUnique({\n        where: { clerkId },\n    })\n\n    if (!tenant) {\n        const user = await currentUser();\n        const name = (await auth()).orgId ? 'Organization' : (user?.firstName ? `${user.firstName}'s Store` : 'My Store')\n\n        tenant = await prisma.tenant.create({\n            data: {\n                clerkId,\n                name,\n            },\n        })\n    }\n\n    return tenant\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;;;;;;;AAEO,eAAe;IAClB,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,IAAA,2LAAI;IACpC,IAAI,CAAC,QAAQ,OAAO;IACpB,MAAM,UAAU,SAAS;IAEzB,IAAI,SAAS,MAAM,8HAAM,CAAC,MAAM,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE;QAAQ;IACrB;IAEA,IAAI,CAAC,QAAQ;QACT,MAAM,OAAO,MAAM,IAAA,yMAAW;QAC9B,MAAM,OAAO,CAAC,MAAM,IAAA,2LAAI,GAAE,EAAE,KAAK,GAAG,iBAAkB,MAAM,YAAY,GAAG,KAAK,SAAS,CAAC,QAAQ,CAAC,GAAG;QAEtG,SAAS,MAAM,8HAAM,CAAC,MAAM,CAAC,MAAM,CAAC;YAChC,MAAM;gBACF;gBACA;YACJ;QACJ;IACJ;IAEA,OAAO;AACX"}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["file:///Users/flavioazoup/Desenvolvimento/central_integracoes/src/server/services/customer.service.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma'\nimport type { Customer } from '@prisma/client'\n\nexport interface CreateCustomerData {\n    name: string\n    email?: string\n    phone?: string\n    document?: string\n    notes?: string\n}\n\nexport interface UpdateCustomerData {\n    name?: string\n    email?: string\n    phone?: string\n    document?: string\n    notes?: string\n    isActive?: boolean\n}\n\n/**\n * Get all customers for a tenant\n */\nexport async function getCustomers(tenantId: string): Promise<Customer[]> {\n    return await prisma.customer.findMany({\n        where: { tenantId },\n        orderBy: { createdAt: 'desc' },\n    })\n}\n\n/**\n * Get active customers for a tenant\n */\nexport async function getActiveCustomers(tenantId: string): Promise<Customer[]> {\n    return await prisma.customer.findMany({\n        where: {\n            tenantId,\n            isActive: true,\n        },\n        orderBy: { name: 'asc' },\n    })\n}\n\n/**\n * Get a single customer by ID with tenant validation\n */\nexport async function getCustomerById(\n    customerId: string,\n    tenantId: string\n): Promise<Customer | null> {\n    return await prisma.customer.findFirst({\n        where: {\n            id: customerId,\n            tenantId,\n        },\n    })\n}\n\n/**\n * Get customer with integrations\n */\nexport async function getCustomerWithIntegrations(\n    customerId: string,\n    tenantId: string\n) {\n    return await prisma.customer.findFirst({\n        where: {\n            id: customerId,\n            tenantId,\n        },\n        include: {\n            integrations: {\n                orderBy: { createdAt: 'desc' },\n            },\n            _count: {\n                select: {\n                    products: true,\n                    orders: true,\n                },\n            },\n        },\n    })\n}\n\n/**\n * Create a new customer\n */\nexport async function createCustomer(\n    data: CreateCustomerData,\n    tenantId: string\n): Promise<Customer> {\n    return await prisma.customer.create({\n        data: {\n            ...data,\n            tenantId,\n        },\n    })\n}\n\n/**\n * Update a customer\n */\nexport async function updateCustomer(\n    customerId: string,\n    data: UpdateCustomerData,\n    tenantId: string\n): Promise<Customer> {\n    // First verify the customer belongs to this tenant\n    const customer = await getCustomerById(customerId, tenantId)\n    if (!customer) {\n        throw new Error('Customer not found or access denied')\n    }\n\n    return await prisma.customer.update({\n        where: { id: customerId },\n        data,\n    })\n}\n\n/**\n * Delete a customer (hard delete)\n * Note: This will cascade delete all integrations, products, and orders\n */\nexport async function deleteCustomer(\n    customerId: string,\n    tenantId: string\n): Promise<void> {\n    // First verify the customer belongs to this tenant\n    const customer = await getCustomerById(customerId, tenantId)\n    if (!customer) {\n        throw new Error('Customer not found or access denied')\n    }\n\n    await prisma.customer.delete({\n        where: { id: customerId },\n    })\n}\n\n/**\n * Soft delete a customer (set isActive to false)\n */\nexport async function deactivateCustomer(\n    customerId: string,\n    tenantId: string\n): Promise<Customer> {\n    return await updateCustomer(customerId, { isActive: false }, tenantId)\n}\n\n/**\n * Reactivate a customer\n */\nexport async function activateCustomer(\n    customerId: string,\n    tenantId: string\n): Promise<Customer> {\n    return await updateCustomer(customerId, { isActive: true }, tenantId)\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;;;;;;AAuBO,eAAe,aAAa,QAAgB;IAC/C,OAAO,MAAM,8HAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAClC,OAAO;YAAE;QAAS;QAClB,SAAS;YAAE,WAAW;QAAO;IACjC;AACJ;AAKO,eAAe,mBAAmB,QAAgB;IACrD,OAAO,MAAM,8HAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAClC,OAAO;YACH;YACA,UAAU;QACd;QACA,SAAS;YAAE,MAAM;QAAM;IAC3B;AACJ;AAKO,eAAe,gBAClB,UAAkB,EAClB,QAAgB;IAEhB,OAAO,MAAM,8HAAM,CAAC,QAAQ,CAAC,SAAS,CAAC;QACnC,OAAO;YACH,IAAI;YACJ;QACJ;IACJ;AACJ;AAKO,eAAe,4BAClB,UAAkB,EAClB,QAAgB;IAEhB,OAAO,MAAM,8HAAM,CAAC,QAAQ,CAAC,SAAS,CAAC;QACnC,OAAO;YACH,IAAI;YACJ;QACJ;QACA,SAAS;YACL,cAAc;gBACV,SAAS;oBAAE,WAAW;gBAAO;YACjC;YACA,QAAQ;gBACJ,QAAQ;oBACJ,UAAU;oBACV,QAAQ;gBACZ;YACJ;QACJ;IACJ;AACJ;AAKO,eAAe,eAClB,IAAwB,EACxB,QAAgB;IAEhB,OAAO,MAAM,8HAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;QAChC,MAAM;YACF,GAAG,IAAI;YACP;QACJ;IACJ;AACJ;AAKO,eAAe,eAClB,UAAkB,EAClB,IAAwB,EACxB,QAAgB;IAEhB,mDAAmD;IACnD,MAAM,WAAW,MAAM,gBAAgB,YAAY;IACnD,IAAI,CAAC,UAAU;QACX,MAAM,IAAI,MAAM;IACpB;IAEA,OAAO,MAAM,8HAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;QAChC,OAAO;YAAE,IAAI;QAAW;QACxB;IACJ;AACJ;AAMO,eAAe,eAClB,UAAkB,EAClB,QAAgB;IAEhB,mDAAmD;IACnD,MAAM,WAAW,MAAM,gBAAgB,YAAY;IACnD,IAAI,CAAC,UAAU;QACX,MAAM,IAAI,MAAM;IACpB;IAEA,MAAM,8HAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;QACzB,OAAO;YAAE,IAAI;QAAW;IAC5B;AACJ;AAKO,eAAe,mBAClB,UAAkB,EAClB,QAAgB;IAEhB,OAAO,MAAM,eAAe,YAAY;QAAE,UAAU;IAAM,GAAG;AACjE;AAKO,eAAe,iBAClB,UAAkB,EAClB,QAAgB;IAEhB,OAAO,MAAM,eAAe,YAAY;QAAE,UAAU;IAAK,GAAG;AAChE"}},
    {"offset": {"line": 211, "column": 0}, "map": {"version":3,"sources":["file:///Users/flavioazoup/Desenvolvimento/central_integracoes/src/server/actions/integration-schemas.ts"],"sourcesContent":["import { z } from 'zod'\n\nexport type IntegrationProvider = 'nuvemshop' | 'bling' | 'tiny' | 'mercadolivre' | 'tray'\n\nexport const INTEGRATION_PROVIDERS: Array<{\n    value: IntegrationProvider\n    label: string\n    description?: string\n}> = [\n    { value: 'nuvemshop', label: 'NuvemShop', description: 'Plataforma de e-commerce brasileira' },\n    { value: 'bling', label: 'Bling', description: 'Sistema de gestão ERP' },\n    { value: 'tiny', label: 'Olist (Tiny)', description: 'ERP Olist / Tiny - API 2.0' },\n    { value: 'mercadolivre', label: 'Mercado Livre', description: 'Marketplace online' },\n    { value: 'tray', label: 'Tray', description: 'Plataforma de e-commerce' },\n]\n\n// NuvemShop Schema\nconst NuvemShopConfigSchema = z.object({\n    accessToken: z.string().min(1, 'Access token é obrigatório'),\n    userId: z.string().min(1, 'Store ID (User ID) é obrigatório'),\n    userAgent: z.string().min(1, 'User Agent é obrigatório'),\n})\n\n// Bling Schema\nconst BlingConfigSchema = z.object({\n    apiKey: z.string().min(1, 'API Key é obrigatória'),\n})\n\n// Tiny Schema\nconst TinyConfigSchema = z.object({\n    token: z.string().min(1, 'Token é obrigatório'),\n    empresaId: z.string().min(1, 'ID da Empresa é obrigatório'),\n})\n\n// Mercado Livre Schema\nconst MercadoLivreConfigSchema = z.object({\n    accessToken: z.string().min(1, 'Access Token é obrigatório'),\n    refreshToken: z.string().min(1, 'Refresh Token é obrigatório'),\n    clientId: z.string().min(1, 'Client ID é obrigatório'),\n    clientSecret: z.string().min(1, 'Client Secret é obrigatório'),\n    userId: z.string().min(1, 'User ID é obrigatório'),\n})\n\n// Tray Schema\nconst TrayConfigSchema = z.object({\n    storeId: z.string().min(1, 'Store ID é obrigatório'),\n    accessToken: z.string().min(1, 'Access Token é obrigatório'),\n})\n\n// Base schema com provider e customerId\nconst BaseIntegrationSchema = z.object({\n    customerId: z.string().min(1, 'Cliente é obrigatório'),\n    provider: z.enum(['nuvemshop', 'bling', 'tiny', 'mercadolivre', 'tray']),\n})\n\n// Schema union para cada provider\nexport const IntegrationConfigSchemas = {\n    nuvemshop: BaseIntegrationSchema.extend({\n        provider: z.literal('nuvemshop'),\n        ...NuvemShopConfigSchema.shape,\n    }),\n    bling: BaseIntegrationSchema.extend({\n        provider: z.literal('bling'),\n        ...BlingConfigSchema.shape,\n    }),\n    tiny: BaseIntegrationSchema.extend({\n        provider: z.literal('tiny'),\n        ...TinyConfigSchema.shape,\n    }),\n    mercadolivre: BaseIntegrationSchema.extend({\n        provider: z.literal('mercadolivre'),\n        ...MercadoLivreConfigSchema.shape,\n    }),\n    tray: BaseIntegrationSchema.extend({\n        provider: z.literal('tray'),\n        ...TrayConfigSchema.shape,\n    }),\n}\n\n// Helper para validar config baseado no provider\nexport function validateIntegrationConfig(\n    provider: IntegrationProvider,\n    data: unknown\n): { success: boolean; data?: any; errors?: Record<string, string[]> } {\n    const schema = IntegrationConfigSchemas[provider]\n    const result = schema.safeParse(data)\n\n    if (!result.success) {\n        return {\n            success: false,\n            errors: result.error.flatten().fieldErrors,\n        }\n    }\n\n    return {\n        success: true,\n        data: result.data,\n    }\n}\n\n// Helper para extrair config do FormData baseado no provider\nexport function extractConfigFromFormData(\n    provider: IntegrationProvider,\n    formData: FormData\n): Record<string, unknown> {\n    const base = {\n        customerId: formData.get('customerId'),\n        provider,\n    }\n\n    switch (provider) {\n        case 'nuvemshop':\n            return {\n                ...base,\n                accessToken: formData.get('accessToken'),\n                userId: formData.get('userId'),\n                userAgent: formData.get('userAgent'),\n            }\n        case 'bling':\n            return {\n                ...base,\n                apiKey: formData.get('apiKey'),\n            }\n        case 'tiny':\n            return {\n                ...base,\n                token: formData.get('token'),\n                empresaId: formData.get('empresaId'),\n            }\n        case 'mercadolivre':\n            return {\n                ...base,\n                accessToken: formData.get('accessToken'),\n                refreshToken: formData.get('refreshToken'),\n                clientId: formData.get('clientId'),\n                clientSecret: formData.get('clientSecret'),\n                userId: formData.get('userId'),\n            }\n        case 'tray':\n            return {\n                ...base,\n                storeId: formData.get('storeId'),\n                accessToken: formData.get('accessToken'),\n            }\n        default:\n            return base\n    }\n}\n\n// Helper para obter nome padrão da integração\nexport function getDefaultIntegrationName(provider: IntegrationProvider): string {\n    const names: Record<IntegrationProvider, string> = {\n        nuvemshop: 'NuvemShop Store',\n        bling: 'Bling ERP',\n        tiny: 'Olist (Tiny)',\n        mercadolivre: 'Mercado Livre',\n        tray: 'Tray Store',\n    }\n    return names[provider]\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 386, "column": 0}, "map": {"version":3,"sources":["file:///Users/flavioazoup/Desenvolvimento/central_integracoes/src/server/actions/integrations.ts"],"sourcesContent":["'use server'\n\nimport { revalidatePath } from 'next/cache'\nimport { prisma } from '@/lib/prisma'\nimport { getCurrentTenant } from '@/server/services/tenant.service'\nimport { getCustomerById } from '@/server/services/customer.service'\nimport {\n    validateIntegrationConfig,\n    extractConfigFromFormData,\n    getDefaultIntegrationName,\n    type IntegrationProvider,\n} from './integration-schemas'\n\nexport async function saveIntegration(prevState: any, formData: FormData) {\n    const tenant = await getCurrentTenant()\n    if (!tenant) {\n        return { message: 'Unauthorized' }\n    }\n\n    const provider = formData.get('provider') as IntegrationProvider\n    if (!provider) {\n        return { message: 'Provider é obrigatório' }\n    }\n\n    const rawData = extractConfigFromFormData(provider, formData)\n    const validation = validateIntegrationConfig(provider, rawData)\n\n    if (!validation.success) {\n        return {\n            errors: validation.errors || {},\n            message: 'Validação falhou',\n        }\n    }\n\n    const { customerId, ...configData } = validation.data!\n\n    // Verify customer belongs to this tenant\n    const customer = await getCustomerById(customerId, tenant.id)\n    if (!customer) {\n        return { message: 'Cliente não encontrado ou acesso negado' }\n    }\n\n    // Extract config object (remove customerId and provider from config)\n    const { provider: _, ...config } = configData\n\n    try {\n        await prisma.integration.upsert({\n            where: {\n                customerId_provider: {\n                    customerId,\n                    provider,\n                },\n            },\n            update: {\n                config,\n                isActive: true,\n            },\n            create: {\n                tenantId: tenant.id,\n                customerId,\n                provider,\n                name: getDefaultIntegrationName(provider),\n                config,\n            },\n        })\n\n        revalidatePath('/dashboard/integrations')\n        return { message: 'Success' }\n    } catch (error) {\n        console.error('Error saving integration:', error)\n        return { message: 'Falha ao salvar integração' }\n    }\n}\n\n// Mantido para compatibilidade (pode ser removido depois)\nexport async function saveNuvemShopIntegration(prevState: any, formData: FormData) {\n    formData.set('provider', 'nuvemshop')\n    return saveIntegration(prevState, formData)\n}\n\nexport async function getIntegrations(customerId?: string) {\n    const tenant = await getCurrentTenant()\n    if (!tenant) return []\n\n    // If customerId is provided, verify it belongs to this tenant\n    if (customerId) {\n        const customer = await getCustomerById(customerId, tenant.id)\n        if (!customer) return []\n    }\n\n    const integrations = await prisma.integration.findMany({\n        where: customerId\n            ? { customerId }\n            : {\n                customer: {\n                    tenantId: tenant.id,\n                },\n            },\n        include: {\n            customer: {\n                select: {\n                    id: true,\n                    name: true,\n                    isActive: true,\n                },\n            },\n        },\n        orderBy: { createdAt: 'desc' },\n    })\n\n    return integrations\n}\n\n"],"names":[],"mappings":";;;;;;;;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAOO,eAAe,gBAAgB,SAAc,EAAE,QAAkB;IACpE,MAAM,SAAS,MAAM,IAAA,kKAAgB;IACrC,IAAI,CAAC,QAAQ;QACT,OAAO;YAAE,SAAS;QAAe;IACrC;IAEA,MAAM,WAAW,SAAS,GAAG,CAAC;IAC9B,IAAI,CAAC,UAAU;QACX,OAAO;YAAE,SAAS;QAAyB;IAC/C;IAEA,MAAM,UAAU,IAAA,+KAAyB,EAAC,UAAU;IACpD,MAAM,aAAa,IAAA,+KAAyB,EAAC,UAAU;IAEvD,IAAI,CAAC,WAAW,OAAO,EAAE;QACrB,OAAO;YACH,QAAQ,WAAW,MAAM,IAAI,CAAC;YAC9B,SAAS;QACb;IACJ;IAEA,MAAM,EAAE,UAAU,EAAE,GAAG,YAAY,GAAG,WAAW,IAAI;IAErD,yCAAyC;IACzC,MAAM,WAAW,MAAM,IAAA,mKAAe,EAAC,YAAY,OAAO,EAAE;IAC5D,IAAI,CAAC,UAAU;QACX,OAAO;YAAE,SAAS;QAA0C;IAChE;IAEA,qEAAqE;IACrE,MAAM,EAAE,UAAU,CAAC,EAAE,GAAG,QAAQ,GAAG;IAEnC,IAAI;QACA,MAAM,8HAAM,CAAC,WAAW,CAAC,MAAM,CAAC;YAC5B,OAAO;gBACH,qBAAqB;oBACjB;oBACA;gBACJ;YACJ;YACA,QAAQ;gBACJ;gBACA,UAAU;YACd;YACA,QAAQ;gBACJ,UAAU,OAAO,EAAE;gBACnB;gBACA;gBACA,MAAM,IAAA,+KAAyB,EAAC;gBAChC;YACJ;QACJ;QAEA,IAAA,+IAAc,EAAC;QACf,OAAO;YAAE,SAAS;QAAU;IAChC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;YAAE,SAAS;QAA6B;IACnD;AACJ;AAGO,eAAe,yBAAyB,SAAc,EAAE,QAAkB;IAC7E,SAAS,GAAG,CAAC,YAAY;IACzB,OAAO,gBAAgB,WAAW;AACtC;AAEO,eAAe,gBAAgB,UAAmB;IACrD,MAAM,SAAS,MAAM,IAAA,kKAAgB;IACrC,IAAI,CAAC,QAAQ,OAAO,EAAE;IAEtB,8DAA8D;IAC9D,IAAI,YAAY;QACZ,MAAM,WAAW,MAAM,IAAA,mKAAe,EAAC,YAAY,OAAO,EAAE;QAC5D,IAAI,CAAC,UAAU,OAAO,EAAE;IAC5B;IAEA,MAAM,eAAe,MAAM,8HAAM,CAAC,WAAW,CAAC,QAAQ,CAAC;QACnD,OAAO,aACD;YAAE;QAAW,IACb;YACE,UAAU;gBACN,UAAU,OAAO,EAAE;YACvB;QACJ;QACJ,SAAS;YACL,UAAU;gBACN,QAAQ;oBACJ,IAAI;oBACJ,MAAM;oBACN,UAAU;gBACd;YACJ;QACJ;QACA,SAAS;YAAE,WAAW;QAAO;IACjC;IAEA,OAAO;AACX;;;IAlGsB;IA8DA;IAKA;;AAnEA,+OAAA;AA8DA,+OAAA;AAKA,+OAAA"}},
    {"offset": {"line": 526, "column": 0}, "map": {"version":3,"sources":["file:///Users/flavioazoup/Desenvolvimento/central_integracoes/src/server/actions/customers.ts"],"sourcesContent":["'use server'\n\nimport { revalidatePath } from 'next/cache'\nimport { redirect } from 'next/navigation'\nimport { z } from 'zod'\nimport { getCurrentTenant } from '@/server/services/tenant.service'\nimport {\n    createCustomer,\n    updateCustomer,\n    deleteCustomer,\n    getCustomers,\n    getCustomerById,\n    getCustomerWithIntegrations,\n    getActiveCustomers,\n} from '@/server/services/customer.service'\n\nconst CustomerSchema = z.object({\n    name: z.string().min(1, 'Nome é obrigatório'),\n    email: z.string().email('Email inválido').optional().or(z.literal('')),\n    phone: z.string().optional(),\n    document: z.string().optional(),\n    notes: z.string().optional(),\n})\n\nexport async function createCustomerAction(prevState: any, formData: FormData) {\n    const tenant = await getCurrentTenant()\n    if (!tenant) {\n        return { message: 'Unauthorized' }\n    }\n\n    const rawData = {\n        name: formData.get('name'),\n        email: formData.get('email'),\n        phone: formData.get('phone'),\n        document: formData.get('document'),\n        notes: formData.get('notes'),\n    }\n\n    const validatedFields = CustomerSchema.safeParse(rawData)\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Validation failed',\n        }\n    }\n\n    let customerId: string | undefined\n    try {\n        const customer = await createCustomer(\n            {\n                name: validatedFields.data.name,\n                email: validatedFields.data.email || undefined,\n                phone: validatedFields.data.phone || undefined,\n                document: validatedFields.data.document || undefined,\n                notes: validatedFields.data.notes || undefined,\n            },\n            tenant.id\n        )\n\n        revalidatePath('/dashboard/customers')\n        customerId = customer.id\n    } catch (error) {\n        return { message: 'Failed to create customer' }\n    }\n\n    if (customerId) {\n        redirect(`/dashboard/customers/${customerId}`)\n    }\n}\n\nexport async function updateCustomerAction(\n    customerId: string,\n    prevState: any,\n    formData: FormData\n) {\n    const tenant = await getCurrentTenant()\n    if (!tenant) {\n        return { message: 'Unauthorized' }\n    }\n\n    const rawData = {\n        name: formData.get('name'),\n        email: formData.get('email'),\n        phone: formData.get('phone'),\n        document: formData.get('document'),\n        notes: formData.get('notes'),\n    }\n\n    const validatedFields = CustomerSchema.safeParse(rawData)\n\n    if (!validatedFields.success) {\n        return {\n            errors: validatedFields.error.flatten().fieldErrors,\n            message: 'Validation failed',\n        }\n    }\n\n    try {\n        await updateCustomer(\n            customerId,\n            {\n                name: validatedFields.data.name,\n                email: validatedFields.data.email || undefined,\n                phone: validatedFields.data.phone || undefined,\n                document: validatedFields.data.document || undefined,\n                notes: validatedFields.data.notes || undefined,\n            },\n            tenant.id\n        )\n\n        revalidatePath('/dashboard/customers')\n        revalidatePath(`/dashboard/customers/${customerId}`)\n        return { message: 'Success' }\n    } catch (error) {\n        return { message: 'Failed to update customer' }\n    }\n}\n\nexport async function deleteCustomerAction(customerId: string) {\n    const tenant = await getCurrentTenant()\n    if (!tenant) {\n        return { message: 'Unauthorized' }\n    }\n\n    try {\n        await deleteCustomer(customerId, tenant.id)\n        revalidatePath('/dashboard/customers')\n        redirect('/dashboard/customers')\n    } catch (error) {\n        return { message: 'Failed to delete customer' }\n    }\n}\n\nexport async function getCustomersAction() {\n    const tenant = await getCurrentTenant()\n    if (!tenant) return []\n\n    return await getCustomers(tenant.id)\n}\n\nexport async function getActiveCustomersAction() {\n    const tenant = await getCurrentTenant()\n    if (!tenant) return []\n\n    return await getActiveCustomers(tenant.id)\n}\n\nexport async function getCustomerByIdAction(customerId: string) {\n    const tenant = await getCurrentTenant()\n    if (!tenant) return null\n\n    return await getCustomerById(customerId, tenant.id)\n}\n\nexport async function getCustomerWithIntegrationsAction(customerId: string) {\n    const tenant = await getCurrentTenant()\n    if (!tenant) return null\n\n    return await getCustomerWithIntegrations(customerId, tenant.id)\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 798, "column": 0}, "map": {"version":3,"sources":["file:///Users/flavioazoup/Desenvolvimento/central_integracoes/src/lib/redis.ts"],"sourcesContent":["import Redis from 'ioredis'\n\nconst getRedisUrl = () => {\n    if (process.env.REDIS_URL) {\n        return process.env.REDIS_URL\n    }\n    throw new Error('REDIS_URL is not defined')\n}\n\nexport const redis = new Redis(getRedisUrl(), {\n    maxRetriesPerRequest: null,\n})\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,cAAc;IAChB,IAAI,QAAQ,GAAG,CAAC,SAAS,EAAE;QACvB,OAAO,QAAQ,GAAG,CAAC,SAAS;IAChC;IACA,MAAM,IAAI,MAAM;AACpB;AAEO,MAAM,QAAQ,IAAI,oJAAK,CAAC,eAAe;IAC1C,sBAAsB;AAC1B"}},
    {"offset": {"line": 817, "column": 0}, "map": {"version":3,"sources":["file:///Users/flavioazoup/Desenvolvimento/central_integracoes/src/server/jobs/queue.ts"],"sourcesContent":["import { Queue } from 'bullmq'\nimport { redis } from '@/lib/redis'\n\nexport const SYNC_QUEUE_NAME = 'sync-queue'\n\nexport const syncQueue = new Queue(SYNC_QUEUE_NAME, {\n    connection: redis,\n    defaultJobOptions: {\n        attempts: 3,\n        backoff: {\n            type: 'exponential',\n            delay: 1000,\n        },\n        removeOnComplete: true,\n        removeOnFail: 100,\n    },\n})\n\n// Job Types\nexport interface SyncJobData {\n    tenantId: string\n    integrationId: string\n    jobId: string // Database ID of the SyncJob record\n    type: 'products' | 'orders' | 'inventory'\n}\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;;;AAEO,MAAM,kBAAkB;AAExB,MAAM,YAAY,IAAI,kKAAK,CAAC,iBAAiB;IAChD,YAAY,4HAAK;IACjB,mBAAmB;QACf,UAAU;QACV,SAAS;YACL,MAAM;YACN,OAAO;QACX;QACA,kBAAkB;QAClB,cAAc;IAClB;AACJ"}},
    {"offset": {"line": 847, "column": 0}, "map": {"version":3,"sources":["file:///Users/flavioazoup/Desenvolvimento/central_integracoes/src/server/actions/sync.ts"],"sourcesContent":["'use server'\n\nimport { revalidatePath } from 'next/cache'\nimport { prisma } from '@/lib/prisma'\nimport { getCurrentTenant } from '@/server/services/tenant.service'\nimport { syncQueue } from '@/server/jobs/queue'\n\nexport async function triggerSync(integrationId: string, type: 'products' | 'orders') {\n    const tenant = await getCurrentTenant()\n    if (!tenant) {\n        return { message: 'Unauthorized' }\n    }\n\n    try {\n        // 1. Create SyncJob record\n        const job = await prisma.syncJob.create({\n            data: {\n                tenantId: tenant.id,\n                integrationId,\n                type,\n                status: 'pending',\n            },\n        })\n\n        // 2. Add to BullMQ\n        await syncQueue.add(type, {\n            tenantId: tenant.id,\n            integrationId,\n            jobId: job.id,\n            type,\n        })\n\n        revalidatePath('/dashboard/sync-status')\n        return { message: 'Sync started' }\n    } catch (error) {\n        return { message: 'Failed to start sync' }\n    }\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AAEO,eAAe,YAAY,aAAqB,EAAE,IAA2B;IAChF,MAAM,SAAS,MAAM,IAAA,kKAAgB;IACrC,IAAI,CAAC,QAAQ;QACT,OAAO;YAAE,SAAS;QAAe;IACrC;IAEA,IAAI;QACA,2BAA2B;QAC3B,MAAM,MAAM,MAAM,8HAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YACpC,MAAM;gBACF,UAAU,OAAO,EAAE;gBACnB;gBACA;gBACA,QAAQ;YACZ;QACJ;QAEA,mBAAmB;QACnB,MAAM,2IAAS,CAAC,GAAG,CAAC,MAAM;YACtB,UAAU,OAAO,EAAE;YACnB;YACA,OAAO,IAAI,EAAE;YACb;QACJ;QAEA,IAAA,+IAAc,EAAC;QACf,OAAO;YAAE,SAAS;QAAe;IACrC,EAAE,OAAO,OAAO;QACZ,OAAO;YAAE,SAAS;QAAuB;IAC7C;AACJ;;;IA9BsB;;AAAA,+OAAA"}}]
}